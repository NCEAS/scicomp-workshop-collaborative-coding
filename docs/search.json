[
  {
    "objectID": "github.html",
    "href": "github.html",
    "title": "git & GitHub",
    "section": "",
    "text": "Version control systems (including git) are built to preserve the iterative versions that we create on the way to a final product. For instance, when writing a scientific manuscript we might have several discrete stages (e.g., separate drafts after successive rounds of feedback from collaborators) as well as the sort of small-scale changes we don’t necessarily preserve in separate files (e.g., workshopping a particular sentence for rhetorical flow).\nVersion control systems provide a framework for preserving these changes without cluttering your computer with all of the files that precede the final version."
  },
  {
    "objectID": "github.html#git-specific-background",
    "href": "github.html#git-specific-background",
    "title": "git & GitHub",
    "section": "git-Specific Background",
    "text": "git-Specific Background\ngit can be enabled on a specific folder/directory on your file system to version files within that directory (including sub-directories). In git (and other version control systems) terms, this “tracked folder” is called a repository (which formally is a specific data structure storing versioning information).\nAlthough there many ways to start a new repository, GitHub (or any other cloud solutions, such as GitLab) provide among the most convenient way of starting a repository.\nLet’s distinguish between git and GitHub:\n\ngit: version control software used to track files in a folder (a repository)\n\ngit creates the versioned history of a repository\n\nGitHub: website that allows users to store their git repositories and share them with others (i.e. a graphical user interface or “GUI”)\n\nGitHub is a company that hosts git repositories online and provides several collaboration features. GitHub fosters a great user community and has built a nice web interface to git, also adding great visualization/rendering capacities of your data.\n\nGitHub.com: https://github.com\nA user account: https://github.com/brunj7\nAn organization account: https://github.com/nceas\nNCEAS GitHub instance: https://github.nceas.ucsb.edu/"
  },
  {
    "objectID": "github.html#exploring-github",
    "href": "github.html#exploring-github",
    "title": "git & GitHub",
    "section": "Exploring GitHub",
    "text": "Exploring GitHub\nLet’s navigate over to GitHub and explore some of its features. Here is what the home screen looks like as of February 2022.\n\nLog in with your GitHub account that you should have created prior to this workshop.\n\n\n\nOnce you’ve logged in, you should see something like this:\n\nThis landing page has a nice summary of your recent repositories and activity on the left panel. Click on your icon at the top left corner and navigate to your profile.\n\nYour profile page shows the organizations that you’re a part of, as well as a more detailed view of your GitHub contributions/activities over time. There are also tabs at the top that lead you to your repositories, projects, packages, and starred repositories. If you would like, you can change your GitHub theme to dark mode by clicking on your icon at the top left corner and going to Settings then Appearances. For the purposes of this workshop, the rest of the screenshots for the GitHub website will be in dark mode to differentiate it from RStudio.\n\nIf there is anything else you would like to change about your account, the user settings page should have it.\n\nLooking at a GitHub Repository\nTo check the repositories that you’ve created, click on the Repositories tab. Note that the top left corner has a green button that will allow you to create new repositories. We will come back to that later. Let’s take a closer look at what the ucsb-ds-capstone-2021.github.io repository contains.\n\nThis screen shows the copy of a repository stored on GitHub, with its list of files, when the files and directories were last modified, and some information on who made the most recent changes.\n\nIf we look at the blue rectangle, we can see that there have been 151 commits made to this repository. By clicking on them, we can see the history of changes made to all of the files. Looks like 3 users were making changes in April.\n\nAnd finally, if we examine one of the changes made on April 25, we can see exactly what was changed in each file:\n\nThe red lines have been deleted while the green lines are new additions. Tracking these changes, and seeing how they relate to released versions of software and files is exactly what git and GitHub are good for. We will show how they can really be effective for tracking versions of scientific code, figures, and manuscripts to accomplish a reproducible workflow.\nNote: it is possible to edit and add files entirely on the GitHub website, by navigating to the specific file or repository. However, for this workshop, we will be editing and adding files through RStudio instead.\n\n\n\n\nCreating a Repository on GitHub\nTo stimulate a collaborative GitHub/RStudio workflow, we are going to have 1 person from each group create a new repository on their GitHub account. This will be the repository where everyone shares their files and code.\nTo create a new repository, follow these steps:\n\nNavigate to your profile page and click on the Repositories tab.\nClick on New.\n\n\n\nEnter a descriptive name for your new repository, here we named it git-practice (avoid upper case and use - instead of spaces or _).\nWrite a 1-sentence description about the repository content.\nChoose Public (as of January 2019, GitHub now offers unlimited free private repositories with a maximum of 3 collaborators).\nCheck Add a README file.\n\n\nYay! We’ve just created a new repository! Here is what the landing page should look like:\n\nThis repository is currently public, so it’s visible to anyone, but since we are working in groups, we will need to give access to your group members. Click on the Settings tab for your repository and go to Collaborators.\n\nClick on Add people. Now let’s get the usernames of all of your group members and add them as collaborators to your repository.\n\n\n\n\n\n\nGreat! Now everyone in the group should have access to the repository."
  },
  {
    "objectID": "github.html#create-a-repository-on-github",
    "href": "github.html#create-a-repository-on-github",
    "title": "git & GitHub",
    "section": "Create a Repository on GitHub",
    "text": "Create a Repository on GitHub\n\n\n\n\n\n\nPractice\n\n\n\nNow that we’ve walked through how to create a repository on GitHub let’s try to make our own! Click over to GitHub and create your own repository (with a README.md). We’ll split into breakout groups to try this out and please let us know if any questions come up."
  },
  {
    "objectID": "issues.html",
    "href": "issues.html",
    "title": "GitHub Issues",
    "section": "",
    "text": "Issues are a convenient way of identifying and delegating tasks within a repository as well as documenting progress over time. They can also be used as a digital ‘lab notebook’ for personal use to brainstorm on a novel topic or preserve important links or supplementary material for easy distribution across a whole team.\nImportantly, while issues can definitely be helpful they are not required to successfully use GitHub for collaborating as a team. Issues absolutely have the potential to facilitate division of labor within a team though and are thus worth covering in this training.\nAn additional function that may be outside of the scope of what you need to use within your team is that it allows non-members to flag issues that they’ve had with code written by your team or request additional functionality that doesn’t yet exist in your framework. Depending on your use of packages in R you may have already opened an issue on an existing R package to do just that!\nTo see a more complete example of how issues can be used we can examine the open issues of an established R package.\n\n\nBelow is the GitHub landing page for the googldrive package and you can see that next to the underlined “Code” tab is an “Issues” tab with a gray circle with the number 22 in it. This number notifies us that as of this screen capture, there were twenty two open issues on this package’s GitHub repository. Note that your GitHub interface may be white but it will not change the position of buttons or tabs.\n\nIf you click over to the issues tab you will see the titles of all current “open” (i.e., ongoing) issues on the repository. Each issue has a title and beneath that a unique number following a # as well as how long ago the issue was opened and the GitHub username of the person who opened the issue. On the right side of each issue’s thumbnail you can see the number of comments added to it.\n\nComments can be used to have a full dialogue among different users – potentially both in and outside of the team responsible for managing the code! The conversational aspect of issues can make them functionally similar to an email thread or messaging app chain. This communication can help keep the solutions to tasks well-documented while ensuring that every member of your group can have their voice heard."
  },
  {
    "objectID": "issues.html#creating-your-first-issue",
    "href": "issues.html#creating-your-first-issue",
    "title": "GitHub Issues",
    "section": "Creating your First Issue",
    "text": "Creating your First Issue\nWhen you first visit the Issues tab of your repository it won’t include any open issues and will look like this.\n\nTo create an issue, click the green button and a new page will open that looks like the below.\n\nIn this page you can create a brief title (these are better if they are concise while still trying to convey the broader context for the task identified by the issue) and add a longer comment into the body of the issue. That longer comment can be as simple as a few bullet points of what the problem is or as complex as a markdown-formatted hyperlink-supported thesis on the task at hand.\nWhile issue comments are completely free for you to use as you see fit, it is important to remember that your most frequent collaborator is yourself in the future so a future version of yourself will absolutely thank you for including extra information when you first open an issue. In a team setting like this one, extra detail can also really help when the person opening the issue is not the person responsible for editing the code to address it.\nIn addition to the title and main body of the issue you can also see a sidebar on the right containing other options for adding detail to an issue. In particular, the “Assignees” and “Labels” sections can be useful in delegating a task to a specific person or naming the category that this task falls under respectively.\nReturning to our googledrive example for a moment, you can see that the package maintainers use multiple labels on some issues to help communicate across their team what processes are affected by or relevant to each particular issue.\n\nWhen you are creating your first issue however you won’t have any of those customized labels. However, GitHub does offer some pre-built template labels that may suit your needs and makes adding your own customized labels very approachable.\nTo see the current label options, click the “Labels” text or the gear to its right and either scroll and click the desired label(s) from the list or scroll to the bottom and click “Edit labels” to create new labels or modify the template labels."
  },
  {
    "objectID": "issues.html#practice---labels",
    "href": "issues.html#practice---labels",
    "title": "GitHub Issues",
    "section": "Practice - Labels",
    "text": "Practice - Labels\nWhat are some labels that might be useful for your project to divide up issues? Can labels divide tasks related to analysis versus visualization of data? Or use them to further subdivide within those categories?"
  },
  {
    "objectID": "issues.html#opening-an-issue",
    "href": "issues.html#opening-an-issue",
    "title": "GitHub Issues",
    "section": "Opening an Issue",
    "text": "Opening an Issue\nOnce you’ve filled out the title and comment of the issue the green “Submit new issue” button will become clickable and you can click it to open your issue. You can either add labels or assign users to the issue during the initial opening phase or after the fact.\nIssues are automatically viewed as a sequential series of events from the first comment so all future additions to the issue will be added beneath that first comment that defines the title of the issue.\nAt the bottom of the issue there will be an open text box that you can add to with whatever information you feel is valuable in the context of this task. We will talk about closing issues in a moment but even when issues are closed they are always accessible so all documentation within an issue can be used later and is well worth any energy investment you can make.\nThere is also not a time limit on issue comments so issues can remain open and active for as long as you find them useful."
  },
  {
    "objectID": "issues.html#appropriate-issue-scope",
    "href": "issues.html#appropriate-issue-scope",
    "title": "GitHub Issues",
    "section": "Appropriate Issue Scope",
    "text": "Appropriate Issue Scope\nAs a brief aside from the nuts and bolts of how to create and manage an issue, it is important to discuss appropriate issue scope.\nEssentially, an issue should- as much as possible-directly correspond to either a single task or a single conversation. It is not always possible to predict how projects can evolve at the outset so you may find issues spanning multiple tasks despite your best efforts but as much as you can plan to keep a 1-to-1 ratio of tasks to issues you will find delegation and tracking of task completion that much easier.\nPersonally, I am a longtime believer in S.M.A.R.T. goals (i.e., goals that are Specific, Measurable, Attainable, Relevant, and Time-specific), but there are many established ways of partitioning a larger project to achievable sub-tasks and you should use whichever is most intuitive to you.\nIf issues seem like something that your group is broadly interested in it may be worthwhile to have a conversation about some general ‘rules of thumb’ for the scope of tasks identified by issues."
  },
  {
    "objectID": "issues.html#practice---create-an-issue",
    "href": "issues.html#practice---create-an-issue",
    "title": "GitHub Issues",
    "section": "Practice - Create an Issue",
    "text": "Practice - Create an Issue\nNow that we’ve covered what issues are and how to open them, let’s take a minute and create some issues on your repository! On your GitHub repository, click over to the Issues tab and create a new issue. This can be either a placeholder just to have experience creating an issue or a real task that you think the team will have to deal with in the future. We are here if you need clarification!"
  },
  {
    "objectID": "issues.html#closing-an-issue",
    "href": "issues.html#closing-an-issue",
    "title": "GitHub Issues",
    "section": "Closing an Issue",
    "text": "Closing an Issue\nSo, let’s imagine that you have worked through whatever task you identified and are ready to be done with this issue and move on to the next task.\nIf you scroll to the bottom of that issue (where the adding comment textbox is) you will see a purple button titled “Close issue”.\n\nAfter clicking that button a purple check mark will appear on the bottom of the issue’s timeline that identifies the issue as closed and credits the user who closed it.\n\nWhen you return to your issue list you will see that issue is now absent from the list. However, next to the “[number] Open” button you can see a check mark with the number of closed issues.\n\nClicking that “Closed” button will access all past issues that are now closed.\n\nSo, even if an issue was closed in the distant past of your repository on GitHub, you can still easily access and view all of its contents.\nThis greatly facilitates the use of issues in tracking problem solving, brainstorm sessions, and supporting documents. The Scientific Computing Support team at NCEAS uses issues as personal lab notebooks (in addition to the aforementioned uses) to ensure that individual process is well documented while still being easily accessible by other team members.\nAs pointed out earlier though, issues are fundamentally optional to the use of GitHub and may not be needed by your team right now. However, we’d encourage you to try using them in case they do prove helpful to your team!"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Overview",
    "section": "",
    "text": "This workshop provides an overview of what “version control” systems are and how they fit into collaborative coding within your team. Specifically, we are focusing here on an introductory approach to version control that focuses on using git via RStudio and GitHub. We are always happy to improve workshop content so please don’t hesitate to post an Issue on our GitHub repository if you see clear areas for improvement!\n\nTo maximize the value of this workshop to you, we recommend that you take the following steps before the day of the workshop. Depending on whether you’ve used RStudio and/or GitHub before you may have already completed some or all of these steps but please read through the following materials regardless to ensure that all participants arrive with a common foundation of installed programs. If anything is unclear, feel free to reach out to us; our contact information can be found in the “Content Creators” tab."
  },
  {
    "objectID": "index.html#programs-to-install",
    "href": "index.html#programs-to-install",
    "title": "Overview",
    "section": "Programs to Install",
    "text": "Programs to Install\nNote for those of you with a dedicated IT team that has sole power to install software on your computer: you will need to contact them before the workshop to install the following programs.\n\nR & RStudio\nInstall R and its more convenient (in our opinion) user-interface: RStudio.\nIf you already have R, check that you have at least version 4.0.0 by running the following code:\n\nversion$version.string\n\nIf your version starts with a 3 (e.g., the above code returns “R version 3…”), please update R to make sure all packages behave as expected.\n\n\ngit\nInstall git\nIf you are a Windows user, be sure to follow along with “Option 1” in the instructions linked above! That variant gives some under-the-hood tools we’ll implicitly rely on later."
  },
  {
    "objectID": "index.html#accounts-to-create-connect",
    "href": "index.html#accounts-to-create-connect",
    "title": "Overview",
    "section": "Accounts to Create / Connect",
    "text": "Accounts to Create / Connect\n\nGitHub\nCreate a GitHub account using your web browser of choice.\nConnect git to your GitHub profile. You may want to review the “shell” (also known as the “terminal” or “command line”) to help with this step.\nCreate a personal access token (PAT). A token is essentially a more secure password that git requires and you can create one by running the following code in RStudio:\n\n# Install the `usethis` and `gitcreds` packages\n#install.packages(c(\"usethis\", \"gitcreds\"))\nlibrary(usethis); library(gitcreds)\n\n# Add your GitHub username and email\nusethis::use_git_config(user.name = \"Jane Doe\",\n                        user.email = \"jane@example.org\")\n\n# Create a token (Note this will open a GitHub browser tab)\n# See steps 6-10 in GitHub's tutorial (link below)\nusethis::create_github_token()\n\n# Copy your Personal Access Token at the end of the above step!\n\n# Now, give your token to RStudio\n# After you run this line you'll follow some prompts in the \"Console\" tab of RStudio\ngitcreds::gitcreds_set()\n\nAt the end of the above steps your token should be set! For additional information, see GitHub’s PAT Tutorial or the Happy Git with R PAT Tutorial. If this seems a little intimidating, please keep in mind that your experience with downloading programs and creating web accounts will help with these tasks even if you have more minimal coding experience!"
  },
  {
    "objectID": "index.html#websites-to-visit",
    "href": "index.html#websites-to-visit",
    "title": "Overview",
    "section": "Websites to Visit",
    "text": "Websites to Visit\n\nSupplemental Material\nWhile not technically necessary to attend the workshop, if you’d like you can see the content that created the workshop website you are viewing by visiting our GitHub repository here."
  },
  {
    "objectID": "server.html",
    "href": "server.html",
    "title": "NCEAS’ Server",
    "section": "",
    "text": "Working on NCEAS’ Server is similar to working on an entirely separate computer from the laptop or desktop computer on which you typically work. This means that you need to go through the steps of connecting GitHub to your “RStudio” again for the instance of RStudio accessed through Aurora. GitHub’s Personal Access Token is referred to as “token” hereafter for simplicity."
  },
  {
    "objectID": "server.html#getting-started-on-the-server",
    "href": "server.html#getting-started-on-the-server",
    "title": "NCEAS’ Server",
    "section": "Getting Started on the Server",
    "text": "Getting Started on the Server\n\nNecessary Software\nThe only tool that you will need to get set up on NCEAS’ server is RStudio!\nYou likely have worked in the “Console” tab of RStudio (where run lines and outputs appear; see below) but RStudio has another tab to the right of the “Console” called “Terminal” which offers RStudio users access to the command line (a.k.a. the shell). If you are a veteran command line user you may prefer to use the standalone Terminal app on MacOS or PuTTY on Windows but for the sake of keeping your tool kit streamlined, we’ll walk through getting set up on NCEAS’ server using only RStudio’s Terminal tab.\n\n\n\nThe Terminal does not accept R syntax (and the Console doesn’t accept Terminal syntax) so you may notice that some of the code we’ll walk you through below is formatted differently than you would write an R script.\n\n\n\n\n\nGet your Invite Ready!\nAfter your group RSVP’d for this workshop, our team contacted NCEAS’ IT team to get you an invite email to create an account on the server. An example of what that email may look like is included below but there are two key pieces of information:\n\nYour username\nYour temporary password (covered by a red bar in the screenshot).\n\nIf you have not received that email, check your Spam folder for emails from Thomas Hetmank (hetmank@nceas.ucsb.edu) or Nick Outin (outin@nceas.ucsb.edu). If you have not received the email and it is not in your Spam, reach out to our team and we will work to get an invite sent to you.\n\n\n\n\n\nSigning into the Server\nIn the following instructions, all words that look like this should be typed into the Terminal tab and run by pressing return or enter. Note that typing these commands into an R script or R Markdown will not work because it will attempt to run in the Console. All words that look [like this] (i.e., bracketed) should also be typed into the Terminal tab but the specific text should be replaced in a user-specific way that is clarified in the nearby text.\n\nIn the Terminal pane of RStudio, you will “ssh” into the server by running the following code: ssh [your username]@aurora.nceas.ucsb.edu. It is @aurora because the name of the server is Aurora.\nIf this is the first time you’ve accessed the server you will need to enter yes to accept the server’s SSH key.\nYou will then be prompted to enter your [temporary password] (see the above email example). Note that the cursor will not advance as you type but it is registering your entries! There will be no indication that you are typing (such as: “•••••••••”) This throws off many users so hopefully the above note helps set your mind at ease.\nYou will then be prompted to change your “expired” password. We consider your temporary password to be expired as soon as you use it because sharing passwords via email is not secure and this “expiration” lets you set the password to something that only you know at the outset of your time in the server. Note again that the cursor will not advance as you type but it is working! To update your password, enter your [temporary password], then [your strong new password] and finally re-type [your strong new password] to confirm it. Note that your new password should not be “your strong new password” :)\nYou are ready to go! Run exit to log out of the server in the Terminal tab.\nNow that you have set a new password, use your favorite web browser (e.g., Firefox, Chrome, etc.) to access Aurora and click “Login to RStudio Server”\nIn the resulting page, you can sign in with the same username and password you just signed in on the Terminal tab with.\nYou should now be in something that looks very much like RStudio but is housed in a tab on your browser! We will work together from here on out so once you have reached this point, let our team know and we can gather the group before continuing.\n\nIf the above steps have not resulted in successfully accessing Aurora, consult NCEAS’ instructions on first login and/or SSH-specific instructions for Mac vs. Windows and/or email us!"
  },
  {
    "objectID": "server.html#working-on-the-server",
    "href": "server.html#working-on-the-server",
    "title": "NCEAS’ Server",
    "section": "Working on the Server",
    "text": "Working on the Server\n\nStep 1: Connect Server RStudio with GitHub\nTo begin, load the usethis package (install if needed).\n\n# install.packages(\"usethis\")\nlibrary(usethis)\n\nNext, configure your name and the email address you use for your GitHub account.\n\nusethis::use_git_config(user.name = \"Jane Doe\",\n                        user.email = \"jane@example.org\")\n\nIf you would like to check that this worked, you can go to the “Terminal” tab (next to the “Console” tab) and run git config --global --list.\n\n\nStep 2: Create GitHub Token\nYou may use your token that you already generated for your local RStudio if that is easiest, but you can also create a new token specifically for your Server identity.\nTo create a token, you can again use the usethis package to send you to the relevant part of the GitHub website.\n\nusethis::create_github_token()\n\nOnce you have walked through that process and created a new token COPY the long string of letters and numbers. It is often a good move to take a screenshot of the token and store it on your computer for a rainy day.\n\n\nStep 3: Store GitHub Token\nTo store the token in your server identity, run the following line of code:\n\ngitcreds::gitcreds_set()\n\nIn the “Console” tab you will be prompted to follow a short set of questions (answered via entering numbers in the Console) including the Console requesting your GitHub token.\nPASTE the long string you copied in the previous step into the supplied field and continue. Note that if you did not copy the token (or copied something else between then and now thus losing the token from your clipboard) you can refer to the screenshot we recommended you take upon first generating the token.\n\n\nStep 4: Preserve GitHub Token\nYou will also need to tell the server to remember your token so that you don’t need to re-do the “Store GitHub Token” section every time you start a new R session.\nUnfortunately, there are two limitations to this step:\n\nStorage can only be done in the “Terminal” pane with the command line (don’t worry, it’s only one line!)\nStorage must be for a finite amount of time (though it can be a long time!)\n\nTo make the system remember your token, in the “Terminal” pane of RStudio type the following:\ngit config --global credential.helper 'cache --timeout=10000000'\nThis will cache your “credentials” (i.e., your token) for a long time so that you need not worry about this for the time being.\nNot running the above line will make your personal access token expire immediately in the system, even though GitHub considers its expiration date (that you set earlier) separately.\n\n\nOptional Other Steps\nYou may want to configure additional settings, such as:\n\nThe default branch name (for new repositories)\n\n\nusethis::git_default_branch_configure(name = \"main\")"
  },
  {
    "objectID": "branches.html",
    "href": "branches.html",
    "title": "Branches",
    "section": "",
    "text": "A branch is essentially a working environment in your git repository that is separate from your main working area. This can be incredibly useful when you have a task to work on but you don’t want to risk damaging the version of your code that already works. Note that “branch” can be either a noun or a verb as with many of the git vocabulary words discussed earlier (e.g., “commit”, “push”, etc.).\nBranches are typically created with the intent to put the work in the branch back into the main branch when you are done with it. Implicit in that rationale is the fact that most branches are created with a specific task/sub-task in mind and known to be temporary from the outset.\nAs an example, imagine that you want to put a better engine in your car but you don’t want to risk damaging your car as you go about that job. In git terms you could create a branch to work on those mechanical improvements while at the same time preserving your original car separately (in the “main” branch). When you’re done experimenting and happy with the new version of your car, you can merge the two cars keeping all of the improvements you made in your branch.\nEven if you think you’ve never worked with git branches you actually have! All git repositories actually start in a branch named “main” so even if you’ve never intentionally created a branch, you’ve been working in your “main” branch all along."
  },
  {
    "objectID": "branches.html#brief-overview-of-branch-workflow",
    "href": "branches.html#brief-overview-of-branch-workflow",
    "title": "Branches",
    "section": "Brief Overview of Branch Workflow",
    "text": "Brief Overview of Branch Workflow\nBefore diving into the specifics of how to use branches while working with git, let’s take a look at a general overview of that process.\nAs with many other git operations, the first thing to do is pull from GitHub to your local repository to ensure that you’re working with the most up-to-date version of everything in the repo (see Step 1 below).\nOnce that is done, you can create a branch on your local machine (automatically shifting your RStudio project into that new branch). Doing this on your machine also updates GitHub to show that there are multiple branches (see Step 2 below).\nOnce you have created a branch you can work in it locally (and via GitHub directly) as you would normally. You can edit your files locally, commit those changes, pull from GitHub (within the branch), and push to GitHub (see Steps 3-4 below).\nWhen you are done working with the branch (i.e., you’ve finished the task for which you created the branch), you can use GitHub to merge your branch with the main one (see Step 5 below). This puts all of the content in your branch into the main one now (which puts your local version of the “main” branch behind!).\nOnce the two branches are merged on GitHub, go back to your local computer, manually change the branch to the main branch and pull (see Step 7 below). This updates your local version of the main branch and avoids future problems.\nGiven that most branches are not used again after they are merged, it is often a good housekeeping step to then delete your branch on GitHub and locally once you have successfully merged the pull request (see Steps 6 & 8 below). Note that in the below diagram step 6 and 8 occur on either side of step 7 but in truth they can both come after depending on your preference.\nHowever, deletion of the branch either locally or via GitHub must come after step 5!\nAs you can see from the above text and the below diagram, branches have a few more moving parts than the git and GitHub operations we’ve discussed so far. That said, they can be a powerful tool in service of collaborative work because you can have multiple branches active at the same all working on separate tasks. This approach can be an easy (or at least easier) workflow for working together while avoiding conflicts (again, see “Appendix A: Conflicts”).\n\n\n\nNow we’ve gone over this big picture overview, let’s walk step-by-step through creating, working in and ultimately merging branches!"
  },
  {
    "objectID": "branches.html#create-a-branch",
    "href": "branches.html#create-a-branch",
    "title": "Branches",
    "section": "Create a Branch",
    "text": "Create a Branch\nBefore you create a branch, pull from GitHub as a precaution so that you are certain your local repository has the most up-to-date content.\nThat done, click the purple button in the Git tab of RStudio that shows two rectangles connected by a diamond at right-angles from one another.\n\n\n\nIn the resulting dialogue box, give your new branch an informative name. In this example we haven’t given our new branch a great name but in a “real” repository you will greatly appreciate having concise but descriptive branch names.\nOnce you’re happy with the name, click “Create” (you can ignore the other options and buttons on this dialogue box).\n\n\n\nThis will create a confirmation message that is superficially similar to the format of messages returned by other git actions.\n\n\n\nYou will also notice that in your Git tab where previously it said “main” it now shows whatever name you chose for your branch."
  },
  {
    "objectID": "branches.html#work-in-the-branch",
    "href": "branches.html#work-in-the-branch",
    "title": "Branches",
    "section": "Work in the Branch",
    "text": "Work in the Branch\nYou can now work in a branch in the same way that you work with GitHub via RStudio when you are not using branches.\n\nMake edits\nCommit changes locally\nPull from GitHub to reduce the chances of a conflict\nPush your committed changes to GitHub\n\nThe reason you use the same workflow is–as previously stated–even if you don’t typically use branches, all work in git is functionally done in the “main” branch of your repository.\nFor a more in-depth review of the RStudio-GitHub workflow, see Chapter 3: Using GitHub via Rstudio"
  },
  {
    "objectID": "branches.html#closing-a-branch",
    "href": "branches.html#closing-a-branch",
    "title": "Branches",
    "section": "Closing a Branch",
    "text": "Closing a Branch\nOnce you’ve completely finished working in your branch, push your work (if your local files are ahead of the GitHub versions) and go to your repository’s GitHub page.\nOn that page GitHub will helpfully have created a button at the top of the screen notifying you that your branch had recent pushes and will offer a green button to “Compare & pull request”.\nClick that button.\n\nYou will then be prompted to write a title and message for your pull request to give some broader context for what the branch does. This is especially valuable if you are not the one reviewing pull requests as this can help someone quickly familiarize themselves with what you have done.\nOnce you’re satisfied with your title and message, click the green “Create pull request” button.\n\nThat done, GitHub will send you to a page that looks very much like a Github issue (see the chapter on issues). At the top is whatever title and message you just wrote when opening the pull request following by a list of all of the commits in that branch.\nThose commits are “live” and function as hyperlinks in case you want to view how your code is preserved in GitHub.\nNote also that if you realize you forgot to do something in your branch (or if someone asks you change something) you can return to RStudio and commit/pull/push and it will automatically update on the pull request. Pull requests are for merging a whole branch, not for merging just a part of the work in the branch.\nYou or your team can post messages on a pull request as needed (see the text box at the bottom of the below picture).\nIf you are ready to merge a pull request from your branch into the “main” branch click the intuitively-named green “Merge pull request” button.\n\nGitHub will open another text box where you can add a commit message to your acceptance of the pull request. If whoever opened the pull request was sufficiently detailed in their opening comment(s) this may not need to be terribly detailed but it can’t hurt!\nOnce your message is written, click the green “Confirm merge” button.\n\nThe green ‘open’ buttons will change to purple and will use the “merge” icon of two streams combining. As with GitHub issues you can continue to post comments on a merged pull request if you feel it will be valuable for posterity to do so.\nGitHub will also handily create a “Delete branch” button at the bottom of the pull request’s timeline. We recommend that you click it given that your branch’s purpose is served and having irrelevant branches clutters your GitHub and may even cause problems if you have two similarly-named branches where one has been merged and the other has not.\n\nAfter you click “Delete branch” it will be replaced by a “Restore branch” button so you could always reclaim it if need be.\n\nFinally, return to the “Code” tab of your GitHub repository and you can see that the changes we implemented in the branch are now part of the repository’s “main” branch. The branch name is displayed just above the last commit message and the first file in the repository but below the different tab names."
  },
  {
    "objectID": "branches.html#update-local-repository",
    "href": "branches.html#update-local-repository",
    "title": "Branches",
    "section": "Update Local Repository",
    "text": "Update Local Repository\nNow that GitHub has been told to integrate your branch content with the “main” branch, you need to let RStudio know that integration has taken place!\nFirst, click the name of the branch to see all the branch names in your repository and select the “main” branch to flip your local repository over to that branch.\n\n\n\nNotice though that our script went back to the pre-merge version but don’t panic!\nIn order to update your local version of the repository all that you need to do is click the pull button. This brings the content you just merged via GitHub (see above) into your local repository.\n\nYou will get a success message indicating the changes to each file in the same way any other pull would. You can notice between this picture and the previous that the code automatically changes when the pull is complete.\n\n\n\nNow that you merged your branch with the main branch on GitHub and pulled that merged content down to your local version you have successfully start-to-finish used branches in your workflow.\nMany branches can exist at the same time and sometimes it helpful to create a branch starting from another branch, but these special cases obey the same basic structure described above and are outside the scope of this primer.\nThat said, we recommend branches as one way to avoid conflicts when you and your collaborators want to work simultaneously in the same repository on different scripts!"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Content Creators",
    "section": "",
    "text": "This workshop was created and facilitated by a dynamic team that is here to assist you before, during, and after your attendance at the workshop! To learn a bit more about us, see our bios and relevant links below."
  },
  {
    "objectID": "about.html#julien-brun",
    "href": "about.html#julien-brun",
    "title": "Content Creators",
    "section": "Julien Brun",
    "text": "Julien Brun\nbrunj7.github.io –  brunj7 –  @brunj7 – brun@nceas.ucsb.edu\n\nAs a senior data scientist, the core of Julien’s work is to understand the data and computing challenges researchers are facing and help them to translate these challenges into solvable tasks. Julien advises and mentors on how to clean, structure, combine, and analyze their heterogeneous data sets, as well as scaling up their analysis while promoting open and reproducible data science principles.\nJulien is also a Lecturer in the Master in Environmental Data Science program at Bren School of Environmental Science and Management at UC Santa Barbara, where he teaches “good enough” practices in reproducible and collaborative data science."
  },
  {
    "objectID": "about.html#angel-chen",
    "href": "about.html#angel-chen",
    "title": "Content Creators",
    "section": "Angel Chen",
    "text": "Angel Chen\n angelchen7 – anchen@nceas.ucsb.edu\n\nAngel supports LTER synthesis working groups by developing data pipelines and reproducible analytical workflows to integrate various sources of data. Angel previously worked as a data curator for the Arctic Data Center, helping researchers archive and store their data. Angel recently completed a B.S. in statistics & data science at the University of California, Santa Barbara."
  },
  {
    "objectID": "about.html#nick-lyon",
    "href": "about.html#nick-lyon",
    "title": "Content Creators",
    "section": "Nick Lyon",
    "text": "Nick Lyon\nnjlyon0.github.io –  njlyon0 –  @scilyon – lyon@nceas.ucsb.edu\n\nNick has been working on GitHub for years but has only relatively recently started using it to code collaboratively. When he first heard of git/GitHub (as a graduate student) he used it exclusively to track his own solo work. Now that he collaborates with others via GitHub, Nick has a renewed appreciation for the value of version control in team coding work. Nick completed his MS in Ecology and Evolutionary Biology at Iowa State University"
  },
  {
    "objectID": "motivations.html",
    "href": "motivations.html",
    "title": "Workflows",
    "section": "",
    "text": "If you are working on any file that is the product of iterative edits, you have had to develop a workflow to approach that task. This could be a scientific paper, analytic code, or a presentation. There are many possible ways you could approach this task leveraging any number of software and hardware options but before we get into our discussion today about collaborative research using GitHub we would like to–briefly–outline some of the typical forms these workflows can take and how they fit into a broader framework of individual and synthesis science.\n\n\nAt its simplest, you could be storing your data and code on your local machine and doing the entirety of your work alone. When working on your code you would iteratively edit and save the same code file and you would have a static folder (or folders) for data that you added to as you collected and entered or downloaded additional data.\nThere are variants of this where you may be archiving everything on your hard drive (e.g., Time Machine on Mac OS, etc.) and you may be using a “save as” feature to preserve some iterations of your code. You may also perform this same operation within a cloud-based storage system (e.g., Box, Dropbox, Google Drive, etc.) so that some versions of both code and data are preserved based on time stamps.\nThis approach has the advantage of relatively few moving parts but such editing of your code loses all previous versions that aren’t explicitly preserved (as well as a record of the changes).\nAnother limitation of this approach is that to work collaboratively, everything would need to be manually shared with your collaborator(s) which introduces a significant risk that someone in the research team would accidentally use the “wrong” version of either the code or the data.\n\n\n\n\n\n\nThe above approach works when doing largely individual research, but what about at other stages in the typical lifecycle of data? Said lifecycle is displayed below where data is acquired via planning and collection, data are assessed and preserved, and finally, data are synthesized and used to inform future plans.\nIndividual workflows performed by a small research team can be well-served by the relatively bare-bones workflow illustrated above but such projects often emphasize data acquisition and preservation over synthesis and thus are not as limited by a need for real-time collaboration on coding scripts across a team. Individual projects certainly do data synthesis, they just by their nature have to emphasize data collection at least as much as the synthetic components of research.\nHowever, for larger teams–especially those that span disciplinary boundaries or have ongoing data collection protocols (e.g., research coordination networks, working groups, etc.)–the synthesis part of the data lifecycle often becomes progressively more important. This importance is tightly linked to a need for collaboration among team members on wrangling, analysis, and visualization scripts that in individual workflows can be managed by a single team member but cannot be in synthesis projects.\nCollaboration on coding can be accomplished by manually sharing code and data among group members but there are programs and websites that are specifically dedicated to meeting the need for collaboration. One example is “version control” systems (e.g., GitHub, SVN, etc.) that provide a framework for reproducible group work.\n\n\n\n\n\n\nVersion control systems preserve the iterative changes you and your team make to code and allow for informative titles and messages to be attached to these snapshots. This offers a clear advantage over ambiguous time-stamped versions preserved by cloud storage systems as it facilitates re-visiting code long after or by new team members who were not present for the initial writing. This approach is what we will be covering in greater depth in a few moments but the broad strokes are that you would preserve the history of your work and ensure that everyone uses the “right” version of the code.\nHowever, despite its advantages for collaborative coding, version control is not meant for preserving data so you would need to share data with your collaborators either via email or by storing data in the cloud and sharing links with team members. Depending upon how you implement either route for sharing data (email vs. cloud) your group is still at risk for group members using different versions of the data–especially if your group is involved in ongoing data collection.\nFurther, an inconvenience associated with this workflow is that each group member will store their copy of the data in a different network of nested folders on their local machine. This means that all references in the code to the path of the data (e.g., “home/users/me/project/data/…”) will differ, so running a collaboratively-developed piece of code would require careful specification to avoid getting a ‘this folder does not exist’ error. This is absolutely surmountable but can be a source of frustration over longer project timelines.\n\n\n\n\n\n\nFinally (for our purposes), you could build NCEAS’ server into your workflow to not only collaborate with colleagues on code but also centralize your data storage!\nThis method has all of the coding advantages of a workflow with version control (see above) in that it still facilitates reproducibility, transparency, and collaborative work. However, it also offers a secure location for all of your data to be stored that is accessible to all members on the same folder path.\nThis means that even though each group member could code separately in their own ‘home’ folder on the server (and send those changes back and forth with GitHub) all code could reference the same data location in the ‘shares’ folder on the server. This guarantees not only that all team members are using the same version of the data but that they are using the same exact data file.\nData can be moved from a specific computer onto the server by using any “File Transfer Protocol” (FTP) software (or “SSH FTP” a.k.a. SFTP). These programs function very much like the file manager on your computer (e.g., Finder on Mac) and allow simple dragging-and-dropping of files between your computer and the server. NCEAS has a tutorial on how to go about setting up an FTP or SFTP program on your computer that we are also happy to go over in greater depth as needed!\nAdding the server to your team’s workflow also allows you to work on code both on your folder in the server and on your personal computer as needed. This means that using the server for some of your coding needs does not mean that you are limited to solely using the server ad infinitum thereafter.\nAn ancillary benefit of this approach is the dramatic improvement in computational power when using the server (as compared to even a fast personal computer)\n\n\n\n\n\n\nWhile each approach offers its own strengths and weaknesses, in our experience many scientists avoid the latter two options due to knowledge barriers about how to get set up in these programs and websites, much less how to actually navigate those systems once set up!\nToday, we will strive to cover the fundamentals of using a version control system in your workflow (Option 2) and–for some groups, depending on interest–how to extend that workflow further and leverage NCEAS’ server to share data and work on code.\nPlease don’t hesitate to ask questions and remember that this link is a resource that you should feel free to refer back to if you ever need a refresher or wish to teach peers! There are supplementary appendices as well which we do not anticipate being able to get to today but we do think are likely to be valuable to you as your confidence with these systems grows."
  },
  {
    "objectID": "readmes.html",
    "href": "readmes.html",
    "title": "Informative READMEs",
    "section": "",
    "text": "A README does exactly what its name suggests: it contains a summary of all of the information needed to navigate a given folder’s contents. However, you are responsible for creating a README and adding content to it so it’s value is somewhat dependent upon the time you are willing and able to spend on fleshing it out.\nIn GitHub, READMEs can be particularly useful because they form a landing page at the bottom of your repository’s GitHub page that can be a great way of introducing new people to your project or refreshing ‘future you’ on how you stored things for a given project.\nA README is almost always either a Markdown file (ending in “.md”) or an R markdown file (“.Rmd”). The default for a GitHub repository is “.md” but if you want your README to run R code (e.g., to create graphs, run analysis, etc.) you can create a .Rmd one that can support R code chunks."
  },
  {
    "objectID": "readmes.html#example-readme",
    "href": "readmes.html#example-readme",
    "title": "Informative READMEs",
    "section": "Example README",
    "text": "Example README\n\nLet’s check out the README for the R package lterpalettefinder as one example of an informative README. This R package was developed by the LTER Network Office to share official palettes derived from photos taken at LTER sites and evolved to include a suite of R functions that allow color palettes to be extracted from any user-supplied photo.\nThe README for lterpalettefinder is crucial because it provides the following information:\n\nBrief description of the purpose / utility of the package\nInstructions on how to install the “development version” of the package\n\nThis is useful because the version of a package that is on CRAN (and can be installed with install.packages()) is often less up-to-date than the version that is available on GitHub\n\nList of current functions and what they do\nHex logo of the package\n\nVisitors to the README see the following:\n\nThis README contains a bunch of “bonus” information including nice aesthetic touches and various “badges” denoting timing of last commit and that the package has no errors among other things.\nThe “README.Rmd” file in the GitHub repository can be found at the bottom of the repository list of files (which works out to be just above the rendered README landing page!).\n\nIf you click that file, you can view the “raw” file which is written in “markdown syntax”. Markdown syntax is a simplified (relatively) way of formatting text that provides coarse control without getting bogged down in potentially unnecessary levels of detail. Markdown syntax is discussed extensively elsewhere and your README can be very valuable with just plain text in a .md file so we will avoid discussing it in detail here.\nThe main take away here is that “under the hood”, this package’s README landing page is generated from the formatting specified in this “raw” file. Flip back and forth between the raw view and the displayed README and see if you can catch how various text formatting was accomplished!"
  },
  {
    "objectID": "readmes.html#writing-a-readme",
    "href": "readmes.html#writing-a-readme",
    "title": "Informative READMEs",
    "section": "Writing a README",
    "text": "Writing a README\nWe recommend that you edit your README to include (some of) the following components:\n\nAn informative, un-abbreviated title (beginning with one # to make it a header)\nA brief (likely bulleted) description of the major folders in the repository\nHow / in which folder to contribute new files to the repository\nContact information for primary contact for questions\nIf applicable, links to related repositories (e.g., other repositories created by your working group)\n\nThe most important thing is that you structure your README in a way that is intuitive to your team so that you feel capable to maintain it so that is remains useful and relevant as a landing page for your project."
  },
  {
    "objectID": "readmes.html#other-resources-for-readmes",
    "href": "readmes.html#other-resources-for-readmes",
    "title": "Informative READMEs",
    "section": "Other Resources for READMEs",
    "text": "Other Resources for READMEs\nNavendu Pottekkat made a really cool “Awesome README” that includes several optional features to make a README awesome-r. In particular that README includes special badges showing the timing of the last commit and features embedded header and footer images. This type of aesthetic modification is not required but can be a fun way of making your README stand out!"
  },
  {
    "objectID": "conflicts.html",
    "href": "conflicts.html",
    "title": "Conflicts",
    "section": "",
    "text": "Merge conflicts are a normal part of the git workflow so don’t get discouraged when you run into them! They occur when git cannot figure out how to automatically merge new changes together. This can happen when you and your collaborators change the same lines in the same file without first pulling the changes that the other party has made."
  },
  {
    "objectID": "conflicts.html#brief-overview-of-merge-conflict-workflow",
    "href": "conflicts.html#brief-overview-of-merge-conflict-workflow",
    "title": "Conflicts",
    "section": "Brief Overview of Merge Conflict Workflow",
    "text": "Brief Overview of Merge Conflict Workflow\nSo the basic steps to resolving a merge conflict using RStudio are as follows:\n\nWhen a conflict happens, your local file will automatically be modified to include both possible lines (wrapped in some formatting characters described in greater detail below)\nEdit the lines in your file(s) that caused the merge conflict to your desired status\nCommit those changes\nPush your changes to GitHub\n\nWe can see those steps visually in the following workflow diagram:"
  },
  {
    "objectID": "conflicts.html#how-merge-conflicts-happen",
    "href": "conflicts.html#how-merge-conflicts-happen",
    "title": "Conflicts",
    "section": "How Merge Conflicts Happen",
    "text": "How Merge Conflicts Happen\nBelow is a common scenario that can lead to merge conflicts and then the steps to address a conflict when it occurs.\nLet’s say we have a repository that we’ve shared with a collaborator. Currently there’s a README.md and only one script, test-script.R, in it.\n\n\n\ntest-script.R contains one line. Suppose we want to work on this script and add more lines to it.\n\n\n\nLet’s go commit our edits. The green lines highlight the fact that we’ve added two new lines to our script, lines 2 and 3. We type out our commit message, and click Commit.\n\nGreat! The message “Your branch is ahead of ‘origin/main’ by 1 commit” lets us know that everything is proceeding smoothly. Suppose that we decided to take a break and stepped away from our computer.\n\nThen, unbeknownst to us, our collaborator made their edits to the same script and committed and pushed their changes to the GitHub repository. At the moment, here is what the shared repository looks like.\n\n\n\nWhen we get back to our computer, we’re ready to push our changes to GitHub, but an error shows up. Basically, it is telling us that our GitHub repository contains changes that we do not have on our local computer. To remedy this, the message suggests that we pull the changes from GitHub to our machine to catch our local machine back up.\n\nAfter clicking Pull, we get a new error message: “Merge conflict in test-script.R”.\n\nLooking closer, the merge conflict prompted a new version of test-script.R to pop up. This version contains our edits and our collaborator’s edits, along with the delimiter lines that start with <<<<<<<, =======, and >>>>>>>. git is urging us to manually fix the conflicted lines before continuing.\n\n\n\nOur file now has an U icon, which stands for an unresolved merge conflict.\n\n\n\nIn general terms the steps that come before a merge conflict are displayed in the visual below. Note that though this has visual similarity to the workflow diagrams throughout this bookdown we do not recommend intentionally causing a merge conflict :)"
  },
  {
    "objectID": "conflicts.html#resolving-merge-conflicts",
    "href": "conflicts.html#resolving-merge-conflicts",
    "title": "Conflicts",
    "section": "Resolving Merge Conflicts",
    "text": "Resolving Merge Conflicts\nSo how do we resolve this merge conflict? We need to edit the script so that it looks like how we want it. We can either pick our lines to keep, our collaborator’s lines, some combination, or something new altogether. Be sure to communicate with your collaborator to discuss exactly how it should be fixed. After merging the changes wherever appropriate, delete the delimiter lines.\n\n\n\nThen stage, commit the changes, and push them to GitHub!\n\nPerfect! We’ve fixed the merge conflict!\n\n\n\nLet’s check back on the shared repository. The latest commit shows that we’ve successfully pushed our changes to GitHub.\n\n\n\n\n\n\nNavigating to the commit history, we see that first we committed our changes, then our collaborator committed and pushed their changes, causing a merge conflict since we were editing the same lines in the same file. To resolve this, we edited those lines directly in our RStudio and committed and pushed our changes once more. Finally, the merge conflict is resolved and all the necessary changes are merged."
  },
  {
    "objectID": "conflicts.html#tips-on-avoiding-merge-conflicts",
    "href": "conflicts.html#tips-on-avoiding-merge-conflicts",
    "title": "Conflicts",
    "section": "Tips on Avoiding Merge Conflicts",
    "text": "Tips on Avoiding Merge Conflicts\nMerge conflicts aren’t exactly fun, so here are some tips to avoid them:\n\nCommunicate with your team members often to avoid working on the same files at the same time! Let each other know who is working on what\nCommit frequently and in small chunks\nTry pulling before committing"
  },
  {
    "objectID": "rstudio.html",
    "href": "rstudio.html",
    "title": "RStudio",
    "section": "",
    "text": "Before we get into using git and GitHub through RStudio, it will be helpful to review the major steps of including version control as you work on code.\nBeginning on your local computer, you make changes to a file in a folder that you have previously marked for version control tracking (i.e., a working directory). Once those changes are made you can stage changes within your local computer. After staging, it is best to retrieve the latest file versions from the cloud. You likely will already be up-to-date but this preemptive step can save you a lot of heartache down the line. Once you’ve confirmed that you have the latest file versions, you can shift the revised file(s) to the cloud where any GitHub users with access to your project can access the most recent file and look at the history of all previous changes."
  },
  {
    "objectID": "rstudio.html#git-vocabulary",
    "href": "rstudio.html#git-vocabulary",
    "title": "RStudio",
    "section": "git Vocabulary",
    "text": "git Vocabulary\nFinally, it will be helpful to introduce four key pieces of vocabulary before we dive into the interactive component of this workshop.\n\nClone = copy the entire contents of a GitHub repository to your local computer (done once per computer)\nCommit = move a changed local file to your local staging area (step 2 of the above diagram)\nPull = get file(s) from the cloud to your local computer – opposite of a “push” (step 3)\nPush = move file(s) to the cloud from your local computer – opposite of a “pull” (step 4)"
  },
  {
    "objectID": "rstudio.html#cloning-a-repository",
    "href": "rstudio.html#cloning-a-repository",
    "title": "RStudio",
    "section": "Cloning a Repository",
    "text": "Cloning a Repository\nNow, the first step in using git with RStudio is cloning the repository from GitHub. Note for clarity that in the screenshots below, GitHub is in dark mode while RStudio is in light mode. To clone a repository, follow these steps:\nNavigate to the repository on GitHub and click on Code. Select HTTPS and copy the link.\n\nNow, return to (or open!) RStudio.\n\nGo to the Project tab on the top right corner and click New Project…\n\nSelect Version Control.\n\n\n\nSelect git.\n\n\n\nPaste the repository URL that you just copied from GitHub. Choose a file path to save your project to.\n\n\n\nNow we have finished cloning the repository to our RStudio! Notice that we are working in our git-practice project and that our README.md file shows up under the list of files, just like in our GitHub repository."
  },
  {
    "objectID": "rstudio.html#workflow-refresher",
    "href": "rstudio.html#workflow-refresher",
    "title": "RStudio",
    "section": "Workflow Refresher",
    "text": "Workflow Refresher\nThe typical workflow with git goes like this:\nStep 1: You modify files in your working directory and save them as usual.\nStep 2: You stage files to mark your intention to “commit” them and then commit that version of those files.\n- In RStudio, \"staging\" is done by checking the box next to a given file in the \"Git\" tab\n- Committing files permanently stores them as snapshots to your `git` directory\nStep 3: You pull the most recent changes to make sure you’ve been editing the latest versions.\nStep 4: You push your the version of your files that you committed to GitHub.\nHere is the infographic from the start of this chapter again, which shows the same workflow:"
  },
  {
    "objectID": "rstudio.html#stage-versus-commit",
    "href": "rstudio.html#stage-versus-commit",
    "title": "RStudio",
    "section": "Stage versus Commit",
    "text": "Stage versus Commit\nThe functional difference between “staging” a file and “committing” one can be a little tough to grasp at first so let’s explore that briefly here. We can make an analogy with taking a family picture, where each family member would represent a file.\n\nStaging files is like deciding which family member(s) are going to be in your next picture\nCommitting is like taking the picture\n\nThis 2-step process enables you to flexibly group files into a specific commit. Those groupings can be helpful to you later if you’re trying to find what you changed for a specific task (because those changes likely are all in the same commit)."
  },
  {
    "objectID": "rstudio.html#creating-a-new-file",
    "href": "rstudio.html#creating-a-new-file",
    "title": "RStudio",
    "section": "Creating a New File",
    "text": "Creating a New File\nLet’s try out a simple git workflow by first creating a new file. This is Step 1 of the process. We can add new R scripts and files to our repository through RStudio. Try creating a new script by going to File > New File > R Script. Feel free to type anything you want into this script as an example. Name this script after yourself. In the screenshot below, I have named my script angel-script.R.\nOnce you are done, navigate to the git tab on the upper left corner. You should see your new script show up there along with a .gitignore and git-practice.Rproj file. Do not worry about the .gitignore file for now, it was created by RStudio to make sure that some temporary files are not tracked by git. The git-practice.Rproj file will save your settings and open tabs when you close the project, and will restore these settings the next time you open it.\n\nNotice that there are color-coded icons next to the files in the “Git” tab. These icons are shorthand for the status–according to git–of every* file in your working directory. Not technically “every” file because files that are tracked but haven’t been modified are not included. See below for definitions.\n\n\n\nIn our case, it means that our R script, .gitignore, and git-practice.Rproj files have never been tracked by git (since these files were just created). Note also that the README.md file is not listed, but it exists (check the Files pane). It is because files that are tracked but have no modifications since the last commit are not listed.\n\nAdding our Script to the Next Commit\nLet us look at the diff of our script. Click on the Diff tab.\n\n\n\nChecking our script, we can see the new lines that we just typed are in green, which indicates that these lines have been added for git. We would like to save a snapshot of this version of our script. Since we’ve just done Step 1, here are the rest of the steps we will need to do to get our script to show up on our GitHub repository:\nStep 2: Add the file to the next commit by checking the box in front of the file name. Note that the two ? icons will change to a single A on the left to show you that this file is now staged to be part of the next commit.\nStep 3: In the right pane, type a short but descriptive commit message detailing what you have done so far. Then click on the Commit button to save this version of the script in the git database.\n\nIf all of the above steps went well, you should see something like this:\n\nNotice that git tells us that 1 file changed because we’ve just added a new file to our commit. Now close the window. Before sending our changes back to GitHub, we should make sure that the copy of the repository on RStudio is completely up-to-date with the one on GitHub to avoid any conflicts.\n\n\nGetting the Latest Updates\nThere are two git commands to exchange between a local and remote versions of a repository:\n\npull: git will get the latest remote version and try to merge it with your local version\npush: git will send your local version to the remote version of the repository (in our case GitHub)\n\nBefore sending your local version to the remote, you should always get the latest remote version first. In other words, you should pull first and push second. This is the way git protects the remote version against incompatibilities with the local version. You always deal with potential problems on your local machine. Therefore your sequence will always be:\n\nCommit\npull\npush\n\nOf course RStudio has icons for that on top of the “Git” tab, with the blue arrow down being for pull and the green arrow up being for push. Remember the icons are organized in sequence!\nLet us do the pull and push to synchronized the remote repositories. Click on the Pull button to pull changes (if any) from the GitHub repository to the copy on RStudio. We have now synchronized the local (our computer) and remote (on GitHub) versions of our repository. You may have noticed that all of our preceding graphics use blue for pull-related content and green for push-related information. Hopefully that helps cement the two ideas in your mind!\n\n\n\nIn my case, it turns out that a new script, lyon-script, was added to the GitHub repository by a collaborator while I was making my own script. Since I have just pulled, lyon-script now shows up in my RStudio files.\n\n\n\n\nA new message has popped up for me: “Your branch is ahead of ‘origin/main’ by two commits”. This means that I have two additional commits on my local machine that I never shared back to the remote repository on GitHub. If I look at the content of my repository on GitHub, I will see just the README.md and lyon-script. My changes are NOT in the cloud yet. You might be seeing a similar message as well.\n\n\nSending Changes back to GitHub\nSo how do we send our changes back to GitHub? Locate the Push button on the “Git” tab and click on it. Now your script should show up in the GitHub repository!\n\n\n\nOnce you click that button you should get a success screen like the one pictured below.\n\n\n\nNavigate back to the GitHub website and find your repository. Check to see if your script has been added correctly. In my case, angel-script.R finally shows up in my repository.\n\n\n\nRinse and Repeat\nGreat! Now that your script has been added to the group repository, you should try to repeat the same workflow over again just to get a feel for how it works. Go back to RStudio and edit your own script. Save those edits, add your edited file to the staging area, write a commit message, then commit your changes. After committing, make sure to pull first then push after! When you pull, you might notice that scripts from your group members/collaborators will show up in your RStudio files.\nMake sure to work on your own script. If you and another group member work on the same script at the same time, this may lead to merge conflicts with git. If two people were to work on the same script, they may be making different edits on the same lines, and git would not know which edits to keep. To avoid merge conflicts, be mindful of what files you are working on and always communicate this to your group members!"
  },
  {
    "objectID": "forks.html",
    "href": "forks.html",
    "title": "Forks",
    "section": "",
    "text": "A fork is a duplicate of a git repository that is owned by someone other than you. Any repository that you can view on GitHub, you can fork. Forks allow you to start with a complete repository and then edit it for your own use as needed.\nThe difference between forks and branches is a source of great confusion for many (even veteran!) git users but hopefully this list helps to clarify:\n\nA fork creates a new repository while a branch exists within a given repository\nA fork is owned by a different user/organization than the original, a branch does not change repository ownership\nA fork’s “parent” repository is not recognized by git but git does ‘know’ which branch a given branch originates from."
  },
  {
    "objectID": "forks.html#choosing-whether-to-fork-or-to-branch",
    "href": "forks.html#choosing-whether-to-fork-or-to-branch",
    "title": "Forks",
    "section": "Choosing Whether to Fork or to Branch",
    "text": "Choosing Whether to Fork or to Branch\nA good rule of thumb for whether you should fork or branch a repository is based on whether you’re working independently from the owner of the repository versus collaborating actively with them.\nIf you are largely independent from the repository’s owner, fork that repository to get your own copy to independently work in. If you are actively collaborating, it is likely that you’ll want to work in a branch.\nIt is important to note that both forks and branches can be merged back into their source (the “main” branch for branches and the original repository for forks) via pull request so you need not worry that choosing one or the other will preclude integration with the source."
  },
  {
    "objectID": "forks.html#brief-overview-of-fork-workflow",
    "href": "forks.html#brief-overview-of-fork-workflow",
    "title": "Forks",
    "section": "Brief Overview of Fork Workflow",
    "text": "Brief Overview of Fork Workflow\nForking is (arguably) one of the more straightforward git workflows but before we cover it in detail, let’s review the broader context.\nYou begin by going to the GitHub page for a repository that you do not own. From there, there is a convenient “Fork” button you can click that (after a screen very much like that of creating a new repository) creates a duplicate of the repository in your profile’s repository list.\nOnce the fork is created, you simply clone the repository as you would when beginning work with any other GitHub repository.\nFrom there on you work as your normally would with GitHub: edit, commit, pull, and push.\nWhile it is not shown in the below diagram, if needed you can submit a “pull request” (see Appendix B: Branches) to merge your version of the repository with the version you initially forked from. This is not a required part of the workflow which is why it is excluded from the diagram.\n\n\n\nNow we’ve covered the general operation of forking, let’s go over the specifics step-by-step."
  },
  {
    "objectID": "forks.html#create-a-fork",
    "href": "forks.html#create-a-fork",
    "title": "Forks",
    "section": "Create a Fork",
    "text": "Create a Fork\nOn GitHub, navigate to the repository that you would like to fork for your own use. Note that in this case the repository we created to take these screen captures is very new but this need not be the case!\nIn the top right of the repository’s GitHub page there is a “Fork” button (between “Unwatch” and “Star”), click it to begin forking.\n\nThis redirects you to a page that is very similar to the page for creating a new repository de novo (see Chapter 3: Using GitHub).\nHere you can select who you want to own the repository from a dropdown including any organizations you are a member of and your username if you want to personally own the fork.\nYou can also change the repository name (though the default is to retain the same name) and add a description of your purpose for the fork.\nYou may notice that in this page you do not have the option to specify public versus private or any of the ‘initialize’ steps (e.g., README, gitignore, or licence). Forks will inherit these settings from the repository they are forked from so they do not need to specified here.\nOnce you are happy with the owner of the fork, the name, and the description, click the green “Create fork” button.\n\nDepending on the amount of content in the repository you are forking and your internet speed this may take anywhere from a few seconds to 1-2 minutes so you will need to wait for a moment while GitHub creates a new duplicate repository under the control of the owner you specified.\nAfter the process completes the page will refresh and you will find yourself on the landing page for your new forked repository!\n\nThis repository has a fork icon in the top left (to the left of the owner/repository name) and includes a link to the repository that it came from just beneath that.\nThe other salient difference is that between the branch and “Code” buttons and the list of files there is a bar that indicates whether the fork is up to date with the repository it was forked from.\nIf the “parent” repository is updated (i.e., someone pushes changes to it after you forked) you can click the “Fetch upstream” button to integrate those changes with your fork.\nIf you decide that your changes are a meaningful improvement that the parent repository could benefit from, you can click the “Contribute” button to begin the process of submitting a pull request to integrate your edits with the parent (see Appendix B: Branches for instructions on submitting a pull request).\nFrom here on you can work within your fork as you would within any other repository! Clone the fork into your local computer and work as you normally would (see Chapter 4: Using GitHub via RStudio for a refresher on that workflow if needed)"
  }
]